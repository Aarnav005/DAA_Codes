/*
 * Time Complexities of Algorithms:
 *
 * 1. Max-min using divide and conquer: O(n)
 * 2. Stassen's matrix multiplication using divide and conquer: O(n^log 7)
 * 3. Quicksort using divide and conquer: O(n log n) (average case), O(n^2) (worst case)
 * 4. Mergesort using divide and conquer: O(n log n)
 * 5. Single source shortest path (Dijkstra's algorithm): O((V + E) log V), where V is the number of vertices and E is the number of edges
 * 6. Activity selection problem (Greedy approach): O(n log n)
 * 7. Fractional knapsack (Greedy approach): O(n log n)
 * 8. Prim's algorithm (Minimum Spanning Tree): O((V + E) log V), where V is the number of vertices and E is the number of edges
 * 9. Job sequencing with deadline: O(n log n)
 * 10. Matrix chain multiplication (Dynamic Programming): O(n^3)
 * 11. All pairs shortest path (Floyd-Warshall algorithm): O(n^3)
 * 12. 0/1 knapsack problem (Dynamic Programming): O(n * W), where n is the number of items and W is the maximum weight capacity
 * 13. Coin change problem using greedy approach: O(n * V), where n is the number of coins and V is the target value
 * 14. Coin change problem using dynamic programming: O(n * V), where n is the number of coins and V is the target value
 * 15. Longest Common Subsequence (LCS) using dynamic programming: O(m * n), where m and n are the lengths of the two input strings
 * 16. Bellman-Ford algorithm (Single source shortest path): O(V * E), where V is the number of vertices and E is the number of edges
 * 17. Optimal Binary Search Tree (OBST): O(n^3)
 * 18. Hamiltonian cycle using backtracking: O(n!), where n is the number of vertices
 * 19. Graph coloring using backtracking: O(n^m), where n is the number of vertices and m is the number of colors
 * 20. N-Queens problem using backtracking: O(n!), where n is the number of queens
 * 21. Rabin-Karp algorithm (String matching): O(n + m), where n is the length of the text and m is the length of the pattern
 * 22. Naive string matching algorithm: O((n - m + 1) * m), where n is the length of the text and m is the length of the pattern
 * 23. KMP algorithm (String matching): O(n), where n is the length of the text
 */

int main() {
    print("OK!");
    return 0;
}